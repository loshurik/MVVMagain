using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MVVMagain.Models
{
    public class Questions
    {
        public string Text { get; set; }
        public Questions()
        {
            Text = "Начну с примера. Допустим вам надо написать UserControl, который будет отображать твитты. Вы нажмете добавить UserControl, накидаете в xaml нужные элементы управления. Далее вы создадите свойство в code behind, где будете хранить твитты. Затем в тот же code behind добавите обработчик событий – например нажатие на UserPicture в твитте. В общем все так же, как если бы вы делали этот контрол с использованием технологий предыдущего покаления вроде WinForms. Повнимательнее присмотримся к этому контролу — у него есть описание части видимой пользователю – те xaml. А так же есть code behind.Теперь положим, вам приходит первый feature request — пользователю захотелось отображать другие твитты, но в таком же точно контроле. Вы может быть сделаете соответствующий флаг в code behind или, если вы более искушены в software design, будете использовать GoF’s стратегию. Спустя какое-то время приходит второй feature request — каждый твитт содержит слишком много ненужной на взгляд пользователя информации и вам нужно сделать новый look вашему контролу, но в то же время не хотите обидеть старых пользователей и оставляете возможность работы со старым визуальным представлением. И так далее – требования поступают все новые, вы используете различные трюки и хитроумные решения, чтобы их реализовать.Стоп! Вернемя назад во времени – к ситуации когда был только один контрол. Что если разнести code behind и сам класс контрола? Те разделить сущность на две. Одну назвать View – это то что видит пользователь, те класс унаследованный от UserControl. А вторую назвать ViewModel – это даные непосредственно связанные с тем, что показывается пользователю через View, а так же функции-обработчики событий, вроде нажатия по аватару. Тогда можно будет легко решить первый feature request – вы просто напишите ViewModel и сопоставите ему старый View. Так же легко будет решить и первый feature request – вы можете сопоставлять одной ViewModel разные View. Хорошая идея – думаете вы.Но как сделать связь между View и ViewModel? Для этого используется data binding – ключевой инструмент в WPF. Вы укажите View тем или иным способом какой DataContext ей использовать, те скажите откуда брать данные, и дальше будете биндиться к данным почти точно так же как и в случае с code behind. Я намеренно опускаю здесь технические детали – они будут рассказыны далее.Так выглядит типичная диаграмма классов для приложения написанного с использованием MVVM:";
        }
    }
}
